/*
 * 객체지향 프로그램 (재사용) => 유지보수
 * 	자바는 클래스로 시작 클래스 종료
 * 	=> 클래스 여러 개(기능 분리) 만들어서 서로 연관 관계
 * 	=> 웹 => 게시판, 공지사항, 장바구니...
 * 	-----------------------------------------
 * 1) 특징
 * 	= 기존의 프로그램을 쉽게 제작 => 재사용
 * 	= 코드의 재사용성이 높다 (코드 변경, 추가) => 상속 / 포함
 * 	= 코드 관리가 용의하다 (메소드 => 구조화)
 * 	= 이미 사용 중인 프로그램을 변경 => 신뢰성이 높은 프로그램
 * 	= 재사용(상속, 포함), 신뢰성 => 에러가 거의 없다
 * 					  ---- 스프링 / 마이바티스
 * 		| 변경, 기능 추가
 * 		class ClassName {
 * 			---------------
 * 			변수 : 프로그램에 필요한 데이터를 저장해서 사용
 * 					=> 한 개만 저장이 가능
 * 					=> 기본형 / 배열 / 클래스 => 변수
 * 			1. 변수의 종류
 * 				=> 인스턴스 변수
 * 					=> 객체 생성 시 마다 메모리에 따로 저장
 * 				=> 공유 변수
 * 					=> 모든 객체가 동시에 사용이 가능
 * 					=> 한 번 변경이 되면 모든 객체가 동시에 변경
 * 					=> 학원명 / 학교명 / 부서명 / 로그...
 * 					static String name...
 * 				---------------------------------------
 * 				자동 기본 초기화
 * 					int => 0, long => 0L
 * 					String => null
 * 					double => 0.0
 * 				=> 지역 변수 => 메소드 블럭 안에서 선언되는 변수
 * 					------- 메소드 안 선언, 매개변수
 * 					------- 메소드 종료되면 자동으로 메모리 해제
 * 					------- 생성 시점 : 메소드 호출 시에 생성
 * 						자동 초기화가 안된다 => 초기화 후에 사용
 * 
 * 					------------------------------------------
 * 						메모리 저장 되는 시점		메모리 해제 되는 시점
 * 					------------------------------------------
 * 					인스턴스		객체 생성			프로그램 종료
 * 							new 생성자()			=> Heap 영역
 * 												=> 사용자 영역
 * 												=> GC(자동 메모리 회수)
 * 					------------------------------------------
 * 					공유변수		컴파일 시에		프로그램 종료	
 * 								자동으로 메모리		=> MethodArea 영역
 * 								저장
 * 					------------------------------------------
 * 					지역변수		메소드 호출 시		메소드 종료
 * 												=> Stack
 * 												=> 메모리 자체 관리
 * 												
 * 					------------------------------------------
 * 					메모리 영역
 * 					------------------------
 * 						1) MethodArea : method, static
 * 						2) Stack : 지역 변수, 매개 변수
 * 						3) Heap : 배열, 인스턴스 변수...
 * 					-----------------
 *	 			---------------
 *				생성자 => 초기화 블럭 => 초기화
 *				----- 초기화 시작하는 프로그램 => 생략 가능
 *					=> 반드시 클래스명과 동일
 *					Scanner scanner = new Scanner(System.in)
 *										  -------
 *										생성자는 반드시 호출 시에 new
 *									new => 클래스의 메모리 크기 확인
 *											=> 메모리 배정
 *									생성자 => 초기화
 *					초기화 블럭 => 호출하지 않는다 => 자동 수행
 *						단점 : 상속의 예외 조건
 *						class ClassName {
 *							{
 *								인스턴스 블럭 => 구현
 *							}
 *							static {
 *								static 블럭 => static 변수의 초기화
 *								DB 연동 / 웹 : 쿠키, 데이터베이스 연결
 *								서버 연결, 쓰레드 작동
 *							}
 *						}
 *				변수 => 명시적 초기화 int age = 20;
 *				웹 => 자동 로그인 (쿠키에서 ID)
 *					class ClassName {
 *						// 선언만 가능 => 구현은 불가능
 *										---
 *										연산자 / 제어문 / 메소드 호출
 *										-----------------------
 *										사용이 불가능 하다
 *						int a; => 선언과 동시에 초기값
 *						a = 10;
 *					}
 * 				---------------
 * 				기능 => 메소드 : 한 개의 기능을 수행하게 만든다
 * 						인스턴스 메소드 : 따로 생성 => 따로 작동
 * 						static 메소드 : 공유 => 한 개만 생성
 * 						추상 메소드 : 선언 => 필요 시 마다 구현
 * 									설계
 * 								추상 클래스 / 인터페이스
 * 						------------- 수정 가능
 * 						종단 메소드 => 사용빈도가 거의 없다
 * 						------------- 수정 불가능
 * 				---------------
 * 				String s1 = "Hello Java"
 * 				String s2 = "Hello Oracle"
 * 				s1.substring(6)
 * 				s2.substring(6)
 * 
 * 				Math.random() => static / 클래스명으로 접근
 * 2) 클래스 => 구성요소
 * 3) 객체지향 3대 특성
 * 		= 데이터 보호 목적 => 캡슐화 (데이터 은닉화) 
 * 							lombok
 * 		= 재사용 => 상속, 포함
 * 				is - a has - a
 * 		= 수정, 추가를 쉽게 만든다
 * 			다형성 => 오버리이딩 / 오버로딩
 * 4) 접근지정어
 * 		public => 모든 클래스에서 사용이 가능
 * 		protected => 같은 풀더 안에서만 접근이 가능
 * 					 상속 받은 클래스는 다른 풀더에서도 접근이 가능
 * 		default => 같은 풀더에서만 접근이 가능
 * 		private => 자신의 클래스에서만 접근이 가능
 * 5) 초기화 => 변수
 * 6) 멤버메소드
 * 7) 메모리 할당
 * 8) 클래스 종류
 * 		** 일반 클래스
 * 		추상 클래스 => 보완 인터페이스
 * 		내부 클래스
 * 			= 멤버 클래스 => 변수 / 메소드를 공유
 * 				=> 스레드, 네트워크
 * 				class A { => Server : 연결 담당
 * 					class B { => 통신 담당 => 스레드
 * 
 * 					}
 * 				}
 * 			= 익명의 클래스 : 상속 없이 오버라이딩 할 경우
 * 				=> 빅데이터 데이터 분석
 * 			= 지역 클래스 => 사용빈도가 없다
 * 				=> 메소드 안에 클래스 선언
 * 				Class A {
 * 					public void aaa() {
 * 						class B {
 * 
 * 						}
 * 					}
 * 				}
 * 				**** 어떤 프로그램에서 사용... 사용처
 * 				**** 개념 : 면접, 사용처(구현)
 * 				게시판, 관리페이지...
 * 9) 예외 처리 : 사전에 에러 방지, 비정상 종료를 방지하고 정상 상태 유지
 * 		= 예외 복구 try ~ catch
 * 		= 예외 회피 throws Exception =>
 * 		= 
 * 		반드시 예외 처리해야 되는 클래스 / 생략이 가능
 * 		------------------------
 * 			| 컴파일 시에 확인			| 실행 시에 확인
 * 			| CheckException		  사용자 에러
 * 				=> 개발자				  UnCheckException
 * 			10장 => 모든 클래스가 예외 처리를 가지고 있다
 * 						java.io / java.sql / java.net
 * 		예외 : 수정이 가능한 에러
 * 				=> 소스 상에서 
 * 				서버 => ip
 * 				오라클 => 주소
 * 				파일 => 파일명
 * 				=> 메모리 할당할 공간이 없다 => 종료 => 에러
 * ------------------ 5, 6, 7, 8 (자바 문법)
 * => 객체지향에 맞게 구현보다는 형식 / 구현
 * 
 * 9장 조립 : 라이브러리 ~ 12장
 * 		getConnection() => 오라클
 * Back-End : 언어(자바, C#, C/C++, 파이썬 / 코틀린, GO, Dart)
 * Front-End : JavaScript : NodeJS, ReactJS VueJS
 * 
 * 퍼블리셔 : HTML / CSS
*/
public class 클래스_1 {
	public static void main(String[] args) {
		
	}

}





















