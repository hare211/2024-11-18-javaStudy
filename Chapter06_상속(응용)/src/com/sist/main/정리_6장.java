package com.sist.main;
/*
 * 객체지향 프로그램 : 하드웨어(집적회로 => 모방)
 * ------------ 조립식(한 개 클래스 => 부품) => CBD
 * => 이미 만들어진 클래스 : 변경(요구사항) => 오버라이딩
 * 1차 => 2차 오버라이딩
 * ----------------- 재사용
 * 
 * 1. 목적 => 재사용
 * 			------ 변경, 추가 가능
 * 						--- 오버로딩
 * 				   --- 오버라이딩
 * 					면접 : 정의 => 부연(프로젝트)
 * 2. 신뢰성이 좋다 : 검증 됐다
 * 3. 대규모 프로젝트 => 재사용
 * 		안산 시청 => 서울 시청
 * 					----- C#, 국민연금 : Pro - C
 * 4. 클래스 => 추상화 => 구체화
 * 			  ----- 설계 --- 구현
 * 			  | 공통적 데이터나 기능을 모아서 설계
 * 				---------------
 * 				 벤치마킹(CGV, 메가박스, 롯데시네마)
 * 						--------------------
 * 						| 불편한 점 => 사용자 편의성
 * 				| 단순화 : 시뮬레이션
 * 
 * 				| 공통 데이터 / 기능
 * 							 --- 메소드
 * 								 ---- 동작
 * 								 메뉴 / 버튼 / 마우스...
 * 
 * 				----------- 변수
 * 							--- 눈에 보이는 데이터 : 명사형
 * 		1. 변수 설정
 * 			=> 기능(메소드에서 공통으로 사용되는 변수)
 * 
 * 			예) 달력
 * 				사용자로부터 입력값 : year / month
 * 				요일을 구한다 : week
 * 				달력 출력 : week 부터 => 1... year / month
 * 				=> 전역 변수 / 멤버 변수
 * 			=> 어떤 기능 => 사용되는 변수 => 중복
 * 	클래스 설계
 * 	class ClassName {
 * 		변수 설정
 * 		저장 데이터 다른 경우 => 따로 저장(인스턴스)
 * 		저장 데이터 1 개 사용 => 정적
 * 
 * 		변수 초기화 여부 : 생성자 => 생략
 * 		생성자 : 윈도우, 데이터베이스, 서버 연결
 * 		없는 경우 => 자동 생성(디폴트 생성)
 * 		생성자 : 여러 개 사용 가능 -> 오버로딩
 * 		=> 클래스명 동일(리턴형 없다)
 * 			** void 도 리턴형
 * 		=> 다른 클래스에서 사용이 가능하게 만드나
 * 			=> public
 * 
 * 		=> 형식)
 * 			[접근지정어] [제어어] 리턴형 메소드명 (매개 변수...) {
 * 				return 값;
 * 			}
 * 
 * 			리턴형 => 처리한 결과값 : 한 개 설정
 * 					기본형 / 배열 / 클래스
 * 			매개 변수 => 사용자가 보낸 값
 * 
 * 			여러 개 사용이 가능 => 가급적이면 3 개이상이면
 * 								배열 / 클래스 이용
 * 
 * 				=> 호출
 * 					인스턴스
 * 						객체 생성 후 처리
 * 						객체.메소드(값...)
 * 					static
 * 						클래스명.메소드()
 * 			*** 인스턴스 메소드, 생성자
 * 				=> 인스턴스 변수, 메소드, static 변수, static 메소드
 * 			*** static 메소드, static 블록
 * 				=> static 변수, static 메소드만 사용 가능
 * 				=> 인스턴스 사용 시에는 반드시 객체 생성 후 사용
 * 				=> 제약이 많다 : 공통 사용
 * 				
 * 	}
 * 
 * 
 */
public class 정리_6장 {
	
}
















